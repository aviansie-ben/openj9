!! Copyright (c) 2018 IBM Corp. and others
!!
!! This program and the accompanying materials are made available under
!! the terms of the Eclipse Public License 2.0 which accompanies this
!! distribution and is available at https://www.eclipse.org/legal/epl-2.0/
!! or the Apache License, Version 2.0 which accompanies this distribution and
!! is available at https://www.apache.org/licenses/LICENSE-2.0.
!!
!! This Source Code may also be made available under the following
!! Secondary Licenses when the conditions for such availability set
!! forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
!! General Public License, version 2 with the GNU Classpath
!! Exception [1] and GNU General Public License, version 2 with the
!! OpenJDK Assembly Exception [2].
!!
!! [1] https://www.gnu.org/software/classpath/license.html
!! [2] http://openjdk.java.net/legal/assembly-exception.html
!!
!! SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception

! All helpers expect the following arguments:
!   startIndex -- r3
!   endIndex   -- r4
!   arrayBytes -- r5
!   val        -- r6
!
! All helpers put their result in r3 and will clobber r4, r7, r8, r9, cr0, cr6, vr0, vr1, vr2, and vr3

.machine "pwr8"

#include "j9cfg.h"
#include "jilconsts.inc"
#include "p/runtime/ppcasmdefines.inc"

#ifdef AIXPPC
.globl .__stringIndexOf_byte
.globl __stringIndexOf_byte{DS}
.globl .__stringIndexOf_short
.globl __stringIndexOf_short{DS}
#elif defined(LINUXPPC64)
.globl FUNC_LABEL(__stringIndexOf_byte)
.type FUNC_LABEL(__stringIndexOf_byte),@function
.globl FUNC_LABEL(__stringIndexOf_short)
.type FUNC_LABEL(__stringIndexOf_short),@function
#else
.globl __stringIndexOf_byte
.globl __stringIndexOf_short
#endif

#if defined(LINUXPPC64)
.section ".text"
.align 2
#endif

#ifdef AIXPPC
.csect __stringIndexOf_byte{PR}
.__stringIndexOf_byte:
.function .__stringIndexOf_byte, startproc.__stringIndexOf_byte, 16, 0, (endproc.__stringIndexOf_byte - startproc.__stringIndexOf_byte)
#elif defined(LINUXPPC64)
FUNC_LABEL(__stringIndexOf_byte):
#else
__stringIndexOf_byte:
#endif
startproc.__stringIndexOf_byte:

! TODO: Implement this
li r3, -1
blr

endproc.__stringIndexOf_byte:

#ifdef AIXPPC
.csect __stringIndexOf_short{PR}
.__stringIndexOf_short:
.function .__stringIndexOf_short, startproc.__stringIndexOf_short, 16, 0, (endproc.__stringIndexOf_short - startproc.__stringIndexOf_short)
#elif defined(LINUXPPC64)
FUNC_LABEL(__stringIndexOf_short):
#else
__stringIndexOf_short:
#endif

startproc.__stringIndexOf_short:

! Special case for empty strings, which always return -1
cmpd cr0, r3, r4
beq .Lshort_not_found

! Calculate the actual addresses of the start and end points
add r3, r3, r3
add r3, r3, r5
add r4, r4, r4
add r4, r4, r5

dcbt r0, r3

! First, splat the value to compare against into vr0 and put its complement in vr3
mtvsrwz vs32, r6
vsplth vr0, vr0, 3
vnot vr3, vr0

! Calculate the end address for what can be compared using full vector compares. After reaching
! this address, the final comparison (if required) needs special handling.
clrrdi r8, r4, 4

! Check if the string is contained within a single 16-byte aligned section with garbage on either
! side. If this happens, we need to handle that case specially.
clrrdi r7, r3, 4
cmpd r7, r8
beq .Lshort_small

! Check if we have 16-byte alignment. Our vector loads require 16-byte alignment, so if we are not
! properly aligned, the first vector load will need to be handled specially.
cmpd r3, r7
beq .Lshort_vector_loop

! We are not on a 16-byte boundary, so we cannot directly load the first part of the string into a
! vector register for comparison. Instead, we load some of the garbage right before the part of the
! string we are interested in. Since we are loading 16 bytes with 16-byte alignment, this is
! guaranteed to never cross a page boundary and thus cannot cause a page fault unless a simple lhz
! to the array would also do so.
lvx vr1, r0, r3

! Before we can run any comparisons on the loaded vector, we must make sure the garbage we read
! from before the string cannot possibly compare as equal to the target value. To do this, we first
! rotate the vector right by n bytes then shift left by n bytes, shifting in the bitwise complement
! of the target value.
#ifdef __LITTLE_ENDIAN__
lvsr vr2, r0, r3
vperm vr1, vr1, vr1, vr2
lvsl vr2, r0, r3
vperm vr1, vr1, vr3, vr2
#else
lvsl vr2, r0, r3
vperm vr1, vr1, vr1, vr2
lvsr vr2, r0, r3
vperm vr1, vr3, vr1, vr2
#endif

! Now we jump into the middle of the vectorized loop so that this specially loaded vector is
! compared the same way any other vector would be.
mr r3, r7
b .Lshort_vector_loop_postload

.Lshort_vector_loop:
lvx vr1, r0, r3

.Lshort_vector_loop_postload:
vcmpequh. vr1, vr1, vr0
bne cr6, .Lshort_found

addi r3, r3, 0x10
cmpd r3, r8
bne .Lshort_vector_loop

.Lshort_residue:

! Now we are done with the part of the loop which can be handled with standard vector instructions.
! If there are no more elements to compare, we are done. Otherwise, we need to handle the remainder.
cmpd r3, r4
beq .Lshort_not_found

! Usually we would have a residue loop here, but it is safe in this case to read beyond the end of
! the string we are comparing against (see comments for the initial unaligned load).
lvx vr1, r0, r3

! Once again, we have to replace the garbage with a value that cannot compare as equal to the
! target value. We do this by rotating the vector left n bytes then shifting right n bytes,
! shifting in the bitwise complement of the target value.
neg r7, r4

#ifdef __LITTLE_ENDIAN__
lvsl vr2, r0, r7
vperm vr1, vr1, vr1, vr2
lvsr vr2, r0, r7
vperm vr1, vr3, vr1, vr2
#else
lvsr vr2, r0, r7
vperm vr1, vr1, vr1, vr2
lvsl vr2, r0, r7
vperm vr1, vr1, vr3, vr2
#endif

vcmpequh. vr1, vr1, vr0
bne cr6, .Lshort_found

.Lshort_not_found:
li r3, -1
blr

.Lshort_small:

! If we got here, then the entire string to search is within one 16-byte aligned vector and the end
! of the string is not aligned to the end of the vector. We do not know whether the start is aligned
! correctly, but we will assume that it was not, since it just means we will end up doing a bit of
! extra work but get the correct answer anyway.

! Just as in the two cases above where we read the first or last vector, we just read the entire
! 16-byte aligned vector containing the characters we want to compare. This will read a vector with
! garbage values on either side of the values we care about, which is safe for reasons explained
! previously.
lvx vr1, r0, r3

! Just as before, we need to replace the garbage in the loaded vector with the bitwise complement
! of the target value. However, this time we have garbage on either side that needs to be fixed
! up. Assume that we have n bytes of garbage before the characters we care about and m bytes of
! garbage after them.

! We start by rotating left m bytes. This has the effect of placing all of the garbage we need to
! replace at the start of the vector register.
neg r7, r4
#ifdef __LITTLE_ENDIAN__
lvsl vr2, r0, r7
#else
lvsr vr2, r0, r7
#endif
vperm vr1, vr1, vr1, vr2

! Next, we need to shift right (n + m) bytes, shifting in the bitwise complement of the target
! value. This causes the garbage to end up at the end of the vector register, having been replaced
! with values that cannot compare as equal to our target value.
subf r7, r4, r3
#ifdef __LITTLE_ENDIAN__
lvsr vr2, r0, r7
vperm vr1, vr3, vr1, vr2
#else
lvsl vr2, r0, r7
vperm vr1, vr1, vr3, vr2
#endif

! Since we are not going to perform any further vector loads after this one, we can simply leave r3
! and the vector register as is. Since the address contained in r3 is actually the address of the
! character that is now the first character in vr1, .Lshort_found will compute the correct address
! of any match.

vcmpequh. vr1, vr1, vr0
bne cr6, .Lshort_found

li r3, -1
blr

.Lshort_found:

! Now that we have done the comparison and seen a match, we know that any half-word that is now
! 0xffff is a match. To figure out what the first match was, we gather the first bit of each
! half-word (in the correct order)...

li r7, 0
lvsl vr0, r0, r7      ! vr0 = 0x000102030405060708090A0B0C0D0E0F
vspltisb vr2, 4       ! vr2 = 0x04040404040404040404040404040404
vslb vr0, vr0, vr2    ! vr0 = 0x00102030405060708090A0B0C0D0E0F0
#ifdef __LITTLE_ENDIAN__
vspltisb vr2, 0xF0    ! vr2 = 0xF0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0
vsububm vr0, vr2, vr0 ! vr0 = 0xF0E0D0C0B0A090807060504030201000
#endif
vbpermq vr0, vr1, vr0
mfvsrd r7, vs32

! Then count the number of leading zeroes, taking into account that the bits we are interested in
! are in not at the beginning of the word.
cntlzw r7, r7
#ifdef __LITTLE_ENDIAN__
addi r7, r7, -24
#else
addi r7, r7, -16
#endif

! Finally, we use that and the address of the last vector loaded to calculate the index of the
! first matching element.
subf r3, r5, r3
srawi r3, r3, 1
add r3, r3, r7
blr

endproc.__stringIndexOf_short:
